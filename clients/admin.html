<!DOCTYPE html>
<html lang="ko">
  <head>
    <title>관리자 페이지</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* 기존 스타일 유지 */
      body {
        font-family: "Inter", sans-serif;
        background-color: #1f2937;
        color: #f3f4f6;
      }
      .status-waiting {
        border-left-color: #facc15; /* Yellow */
      }
      .status-called {
        border-left-color: #34d399; /* Green */
      }
      /* 스크롤바 스타일 */
      .custom-scrollbar::-webkit-scrollbar {
        width: 8px;
      }
      .custom-scrollbar::-webkit-scrollbar-track {
        background: #374151;
      }
      .custom-scrollbar::-webkit-scrollbar-thumb {
        background: #6b7280;
        border-radius: 4px;
      }
    </style>
  </head>
  <body class="p-6 md:p-10">
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ["Inter", "sans-serif"],
            },
          },
        },
      };
    </script>
    <header class="text-center mb-8">
      <h1 class="text-3xl md:text-4xl font-extrabold text-blue-400 mb-2">
        대기열 관리
      </h1>
      <p class="text-lg md:text-xl text-gray-300">
        실시간으로 대기열을 관리하세요.
      </p>
    </header>
    <main
      class="max-w-7xl mx-auto bg-gray-800 p-6 md:p-8 rounded-xl shadow-2xl"
    >
      <section class="mb-8">
        <h2
          class="text-2xl font-bold border-b border-gray-600 pb-3 mb-4 text-blue-300"
        >
          다음 순서 호출
        </h2>
        <div class="flex flex-col md:flex-row gap-4">
          <button
            onclick="callNext()"
            class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition duration-150"
          >
            다음 대기자 호출
          </button>
        </div>
      </section>

      <section class="mb-8">
        <h2
          class="text-2xl font-bold border-b border-gray-600 pb-3 mb-4 text-purple-300"
        >
          고객 대기열
        </h2>
        <div
          class="hidden sm:grid grid-cols-12 text-sm font-semibold text-gray-400 py-2 border-b border-gray-600"
        >
          <span class="col-span-1">번호</span>
          <span class="col-span-3">이름</span>
          <span class="col-span-3">전화번호</span>
          <span class="col-span-2">상태</span>
          <span class="col-span-3 text-right">관리</span>
        </div>
        <div id="queue-list-container" class="max-h-96 overflow-y-auto">
          <ul id="queue-list" class="space-y-3">
            <li class="text-lg text-gray-400 py-2">
              대기열 정보를 불러오는 중입니다...
            </li>
          </ul>
        </div>
      </section>

      <section class="mb-8">
        <h2
          class="text-2xl font-bold border-b border-gray-600 pb-3 mb-4 text-green-300"
        >
          대기자 수동 관리
        </h2>
        <div class="flex flex-wrap gap-4">
          <div
            id="register-section"
            class="flex-grow bg-gray-700 p-6 rounded-lg shadow-inner flex flex-col items-start space-y-4"
          >
            <h3 class="text-lg font-bold text-gray-200">고객 등록</h3>
            <input
              type="text"
              id="register-name"
              placeholder="이름"
              class="w-full p-2 rounded bg-gray-600 border border-gray-500 placeholder-gray-400 text-white"
            />
            <input
              type="text"
              id="register-phone"
              placeholder="전화번호"
              class="w-full p-2 rounded bg-gray-600 border border-gray-500 placeholder-gray-400 text-white"
            />
            <button
              onclick="registerUser()"
              class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 rounded-lg transition duration-150"
            >
              등록
            </button>
          </div>
          <div
            id="specific-call-section"
            class="flex-grow bg-gray-700 p-6 rounded-lg shadow-inner flex flex-col items-start space-y-4"
          >
            <h3 class="text-lg font-bold text-gray-200">특정 고객 호출</h3>
            <input
              type="text"
              id="call-specific-phone"
              placeholder="전화번호"
              class="w-full p-2 rounded bg-gray-600 border border-gray-500 placeholder-gray-400 text-white"
            />
            <button
              onclick="callSpecificUser()"
              class="w-full bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 rounded-lg transition duration-150"
            >
              호출
            </button>
          </div>
        </div>
      </section>

      <section class="mt-8">
        <h2
          class="text-2xl font-bold border-b border-gray-600 pb-3 mb-4 text-yellow-300"
        >
          랭킹 페이지 관리
        </h2>
        <p class="text-gray-400 mb-4">
            랭킹 목록 확인 및 수동 삭제는 별도 랭킹 관리 페이지에서 진행합니다.
        </p>
        <div class="flex justify-start">
            <button
                onclick="goToRankingPage()"
                class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-3 px-6 rounded-lg transition duration-150 flex items-center"
            >
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-6 w-6 mr-2"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                >
                    <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="2"
                        d="M9 19V6l2-2 2 2v13M9 19h12M9 19H3m12-3h-2m2 0V3m-2 2h2m-4 12V3"
                    />
                </svg>
                랭킹 관리 페이지로 이동
            </button>
        </div>
      </section>
      </main>

    <script>
      // API BASE URL을 동적으로 설정합니다.
      const API_BASE_URL =
        window.location.protocol + "//" + window.location.host + "/api/v1";

      const wsProtocol = window.location.protocol === "https:" ? "wss:" : "ws:";
      const websocketUrl = `${wsProtocol}//${window.location.host}/api/v1/queue/ws?mode=full`;

      const queueListElement = document.getElementById("queue-list");
      const registerNameInput = document.getElementById("register-name");
      const registerPhoneInput = document.getElementById("register-phone");
      const callSpecificPhoneInput = document.getElementById(
        "call-specific-phone"
      );

      // 🌟 추가: 완료 처리용 비밀번호 (프론트엔드 자체 검증용)
      const COMPLETION_PASSWORD = "1234";

      let ws;
      let GAMES = [];

      /**
       * 서버에서 게임 목록을 불러와 GAMES 변수를 업데이트합니다.
       */
      async function loadGames() {
        try {
          const response = await fetch(`${API_BASE_URL}/games`);
          if (!response.ok) {
            throw new Error("게임 목록 로드 실패");
          }
          const data = await response.json();
          GAMES = data.games || [];
          console.log("게임 목록 로드 완료:", GAMES);
        } catch (error) {
          console.error("게임 목록을 로드하는 중 오류 발생:", error);
          alert("게임 목록을 불러오는 데 실패했습니다. 관리자에게 문의하세요.");
        }
      }

      function connectWebSocket() {
        // 어드민 페이지이므로 mode=full로 연결 요청 (전체 데이터 수신)
        ws = new WebSocket(`${websocketUrl}`);
        ws.onmessage = function (event) {
          try {
            const data = JSON.parse(event.data);
            if (data.queue_list) {
              updateQueueDisplay(data.queue_list);
            }
          } catch (e) {
            console.error("WebSocket 데이터 처리 오류:", e);
          }
        };
        ws.onopen = () => console.log("WebSocket 연결 성공");
        ws.onclose = (event) => {
          console.log("WebSocket 연결 종료. 재연결 시도...", event.reason);
          // 3초 후 재연결 시도
          setTimeout(connectWebSocket, 3000);
        };
        ws.onerror = (error) => {
          console.error("WebSocket 오류 발생:", error);
          ws.close();
        };
      }

      /**
       * 전화번호를 XXX-XXXX-XXXX 형식으로 포맷합니다.
       * @param {string} phoneNumber - 포맷할 전화번호 (숫자만)
       * @returns {string} 포맷된 전화번호
       */
      function formatPhoneNumber(phoneNumber) {
        if (!phoneNumber) return "";
        const cleanNum = phoneNumber.replace(/[^0-9]/g, "");
        let match;
        if (cleanNum.length === 11) {
          match = cleanNum.match(/^(\d{3})(\d{4})(\d{4})$/);
        } else if (cleanNum.length === 10) {
          match = cleanNum.match(/^(\d{3})(\d{3})(\d{4})$/);
        } else {
          return cleanNum;
        }

        if (match) {
          return `${match[1]}-${match[2]}-${match[3]}`;
        }
        return cleanNum;
      }

      /**
       * 새 고객을 대기열에 등록합니다. (기존 로직 유지)
       */
      async function registerUser() {
        const name = registerNameInput.value.trim();
        const phone_number = registerPhoneInput.value
          .trim()
          .replace(/[^0-9]/g, "");

        if (!name || !phone_number) {
          alert("이름과 전화번호를 모두 입력해주세요.");
          return;
        }

        try {
          const response = await fetch(`${API_BASE_URL}/queue/register`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ name, phone_number }),
          });
          const result = await response.json();

          if (!response.ok) {
            throw new Error(result.detail || "등록 실패");
          }

          alert(`'${name}'님 등록이 완료되었습니다.`);
          registerNameInput.value = "";
          registerPhoneInput.value = "";
        } catch (error) {
          alert(`등록 오류: ${error.message}`);
        }
      }

      /**
       * 다음 순서의 대기자를 호출합니다. (기존 로직 유지)
       */
      async function callNext() {
        try {
          const response = await fetch(`${API_BASE_URL}/queue/call-next`, {
            method: "POST",
          });
          const result = await response.json();

          if (!response.ok) {
            throw new Error(result.detail || "호출 실패");
          }

          alert(
            `다음 고객(${result.called_user_name || "익명"})이 호출되었습니다.`
          );
        } catch (error) {
          alert(`호출 오류: ${error.message}`);
        }
      }

      /**
       * 특정 전화번호를 가진 고객을 호출합니다. (기존 로직 유지)
       */
      async function callSpecificUser(phoneNumber) {
        const phone_number = (phoneNumber || callSpecificPhoneInput.value)
          .trim()
          .replace(/[^0-9]/g, "");

        if (!phone_number) {
          alert("전화번호를 입력해주세요.");
          return;
        }

        try {
          const response = await fetch(
            `${API_BASE_URL}/queue/call-specific/${phone_number}`,
            { method: "POST" }
          );
          const result = await response.json();

          if (!response.ok) {
            throw new Error(result.detail || "호출 실패");
          }

          alert(`고객(${result.called_user_name || "익명"})이 호출되었습니다.`);
          if (!phoneNumber) {
            callSpecificPhoneInput.value = "";
          }
        } catch (error) {
          alert(`호출 오류: ${error.message}`);
        }
      }

      /**
       * 🌟 수정: 고객의 서비스 완료를 처리하고 점수를 랭킹에 등록합니다. (비밀번호 검증 추가)
       */
      async function completeUser(phoneNumber) {
        // 1. 비밀번호 입력 및 검증
        const passwordAttempt = prompt("완료 처리를 위해 비밀번호를 입력해주세요.");
        if (passwordAttempt === null) {
            return; // 사용자가 취소를 누른 경우
        }

        if (passwordAttempt !== COMPLETION_PASSWORD) {
            alert("비밀번호가 일치하지 않아 완료 처리를 할 수 없습니다.");
            return; // 비밀번호 불일치 시 종료
        }

        // 2. 게임 목록 로드 확인 (기존 로직)
        if (GAMES.length === 0) {
          alert("게임 목록을 불러오는 중입니다. 잠시 후 다시 시도해주세요.");
          return;
        }

        // 3. 게임 선택 (기존 로직)
        const gamePrompt = `게임을 선택하세요 (${GAMES.join(", ")}).`;
        let game = prompt(gamePrompt, GAMES[0]);
        if (game === null) return;
        game = game.trim();

        if (!GAMES.includes(game)) {
          alert(`유효하지 않은 게임입니다. 허용된 값: ${GAMES.join(", ")}`);
          return;
        }

        // 4. 점수 입력 및 검증 (기존 로직)
        const scoreString = prompt("게임 점수를 입력해주세요.");
        if (scoreString === null || scoreString.trim() === "") {
          return;
        }
        const score = parseInt(scoreString);
        if (isNaN(score)) {
          alert("유효한 점수(숫자)를 입력해야 합니다.");
          return;
        }

        // 5. 서버에 완료 요청 (기존 로직)
        try {
          const response = await fetch(`${API_BASE_URL}/queue/complete`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              phone_number: phoneNumber,
              score: score,
              game,
            }),
          });
          const result = await response.json();

          if (!response.ok) {
            throw new Error(result.detail || "완료 실패");
          }

          alert(result.message || "요청이 완료되었습니다.");
        } catch (error) {
          alert(`완료 처리 오류: ${error.message}`);
        }
      }

      /**
       * 고객의 대기열 등록을 취소합니다. (기존 로직 유지)
       */
      async function cancelUser(phoneNumber, userName) {
        const phone_number = phoneNumber.replace(/[^0-9]/g, "");

        if (
          !confirm(
            `${userName}님(${formatPhoneNumber(
              phoneNumber
            )})을 대기열에서 취소하시겠습니까?`
          )
        ) {
          return;
        }

        try {
          const response = await fetch(`${API_BASE_URL}/queue/cancel`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              phone_number: phone_number,
              name: userName,
            }),
          });

          const result = await response.json();

          if (!response.ok) {
            throw new Error(result.detail || "취소 실패");
          }

          alert(result.message || "취소 요청이 성공했습니다.");
        } catch (error) {
          alert(`취소 요청 오류가 발생했습니다: ${error.message}`);
        }
      }

      /**
       * 🌟 추가: 랭킹 관리 페이지로 이동하는 함수
       */
      function goToRankingPage() {
        // 랭킹 페이지의 URL을 가정합니다. 필요에 따라 수정해주세요.
        const rankingPageUrl = "/ranking/admin";
        window.location.href = rankingPageUrl;
      }

      /**
       * WebSocket 데이터를 받아 대기열 목록을 화면에 업데이트합니다. (기존 로직 유지)
       */
      function updateQueueDisplay(queueList) {
        queueListElement.innerHTML = "";

        if (queueList.length === 0) {
          const li = document.createElement("li");
          li.className = "text-lg text-gray-400 py-2";
          li.textContent = "현재 대기 인원이 없습니다.";
          queueListElement.appendChild(li);
          return;
        }

        queueList.forEach((item, index) => {
          const li = document.createElement("li");

          let liClass =
            "grid grid-cols-12 gap-2 sm:gap-4 items-center bg-gray-700 p-4 rounded-lg shadow hover:bg-gray-600 transition duration-150 border-l-4";
          let statusText = "대기 중";
          let statusClass = "text-yellow-300";

          if (item.status === "called") {
            liClass += " status-called";
            statusText = "호출됨";
            statusClass = "text-green-300";
          } else {
            liClass += " status-waiting";
          }
          li.className = liClass;

          // 1. 번호
          const numberDiv = document.createElement("div");
          numberDiv.className = "col-span-1 text-base sm:text-lg font-bold";
          numberDiv.textContent = `${index + 1}.`;

          // 2. 이름
          const nameDiv = document.createElement("div");
          nameDiv.className =
            "col-span-3 text-base sm:text-lg font-semibold truncate";
          nameDiv.textContent = item.name;

          // 3. 전화번호 (추가된 부분)
          const phoneDiv = document.createElement("div");
          phoneDiv.className = "col-span-3 text-sm sm:text-base text-gray-400";
          phoneDiv.textContent = formatPhoneNumber(item.phone_number);

          // 4. 상태
          const statusDiv = document.createElement("div");
          statusDiv.className = `col-span-2 text-sm sm:text-base font-medium ${statusClass}`;
          statusDiv.textContent = statusText;

          // 5. 버튼
          const buttonDiv = document.createElement("div");
          buttonDiv.className = "col-span-3 flex justify-end space-x-2";

          // 'waiting' 상태일 때만 '호출' 버튼 표시
          if (item.status === "waiting") {
            const callButton = document.createElement("button");
            callButton.className =
              "bg-yellow-500 hover:bg-yellow-600 text-white text-sm font-bold py-1 px-2 rounded transition duration-150";
            callButton.textContent = "호출";
            callButton.onclick = () => callSpecificUser(item.phone_number);
            buttonDiv.appendChild(callButton);
          }

          const completeButton = document.createElement("button");
          completeButton.className =
            "bg-green-600 hover:bg-green-700 text-white text-sm font-bold py-1 px-2 rounded transition duration-150";
          completeButton.textContent = "완료";
          completeButton.onclick = () => completeUser(item.phone_number);

          const cancelButton = document.createElement("button");
          cancelButton.className =
            "bg-red-500 hover:bg-red-600 text-white text-sm font-bold py-1 px-2 rounded transition duration-150";
          cancelButton.textContent = "취소";
          cancelButton.onclick = () => cancelUser(item.phone_number, item.name);

          buttonDiv.appendChild(completeButton);
          buttonDiv.appendChild(cancelButton);

          li.appendChild(numberDiv);
          li.appendChild(nameDiv);
          li.appendChild(phoneDiv); // 전화번호 추가
          li.appendChild(statusDiv);
          li.appendChild(buttonDiv);

          queueListElement.appendChild(li);
        });
      }

      // 🚨 앱 시작 시 게임 목록을 먼저 로드하고 WebSocket 연결 시작
      loadGames().then(() => {
        connectWebSocket();
      });
    </script>
  </body>
</html>